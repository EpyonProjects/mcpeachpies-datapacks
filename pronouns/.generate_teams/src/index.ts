import { ensureDirSync } from "https://deno.land/std@0.172.0/fs/ensure_dir.ts";

ensureDirSync("./out/afk");
ensureDirSync("./out/exi/afk");

import data from "../data.json" assert { type: "json" };

const AUTOGENERATED_MESSAGE =
  "# Autogenerated by https://github.com/mcpeachpies/mcpeachpies-datapacks/blob/master/pronouns/.generate_teams";

let setupTeams: string[] = [AUTOGENERATED_MESSAGE];

function createTeam(
  name: string,
  prefix: string | undefined,
  suffix: string,
  color: string | undefined
) {
  setupTeams.push(`team add ${name}`);
  if (prefix)
    setupTeams.push(
      `team modify ${name} prefix ["",{"text":"${prefix} ","color":"${
        color || "reset"
      }"}]`
    );
  setupTeams.push(
    `team modify ${name} suffix ["",{"text":"${suffix}","color":"gray"}]`
  );
  if (color) setupTeams.push(`team modify ${name} color ${color}`);
}

[...data.teams.values()].forEach((team) => {
  data.pronouns.single.forEach((single) => {
    createTeam(
      `${team.name}_${single}`,
      team.prefix,
      ` [${single}]`,
      team.color
    );
  });
  data.pronouns.pairs.forEach((x) => {
    data.pronouns.pairs.forEach((y) => {
      if (x != y) {
        createTeam(
          `${team.name}_${x}_${y}`,
          team.prefix,
          ` [${x}/${y}]`,
          team.color
        );
      }
    });
  });
  data.pronouns.triples.forEach((x) => {
    data.pronouns.triples.forEach((y) => {
      data.pronouns.triples.forEach((z) => {
        if (x != y && y != z && x != z) {
          createTeam(
            `${team.name}_${x}_${y}_${z}`,
            team.prefix,
            ` [${x}/${y}/${z}]`,
            team.color
          );
        }
      });
    });
  });
});

console.log(
  `Created ${
    (setupTeams.length - 1) / 4
  } teams for Pronouns (Existence SMP Edition)`
);
Deno.writeTextFile("./out/exi/setup_team.mcfunction", setupTeams.join("\n"));

setupTeams = [
  AUTOGENERATED_MESSAGE,
  "team add mpp_afk",
  'team modify mpp_afk prefix ["",{"text":"[AFK] ","color":"gray"}]',
  "team add afk_Staff",
  `team modify afk_Staff prefix ["",{"text":"ðŸ—¡ ","color":"gray"}]`,
  "team modify afk_Staff color gray",
  "team add afk_StaffPatron",
  'team modify afk_StaffPatron prefix ["",{"text":"ðŸ—¡ ","color":"gray"}]',
  "team modify afk_StaffPatron color gray",
  "team add afk_Patron",
  'team modify afk_Patron prefix ["",{"text":"â˜† ","color":"gray"}]',
  "team modify afk_Patron color gray",
  "team add afk_Trusted",
  'team modify afk_Trusted prefix ["",{"text":"","color":"gray"}]',
  "team modify afk_Trusted color gray",
];

[...data.teams.values()].forEach((team) => {
  data.pronouns.single.forEach((single) => {
    createTeam(
      `afk_${team.name}_${single}`,
      team.prefix,
      ` [${single}]`,
      "gray"
    );
  });
  data.pronouns.pairs.forEach((x) => {
    data.pronouns.pairs.forEach((y) => {
      if (x != y) {
        createTeam(
          `afk_${team.name}_${x}_${y}`,
          team.prefix,
          ` [${x}/${y}]`,
          "gray"
        );
      }
    });
  });
  data.pronouns.triples.forEach((x) => {
    data.pronouns.triples.forEach((y) => {
      data.pronouns.triples.forEach((z) => {
        if (x != y && y != z && x != z) {
          createTeam(
            `afk_${team.name}_${x}_${y}_${z}`,
            team.prefix,
            ` [${x}/${y}/${z}]`,
            "gray"
          );
        }
      });
    });
  });
});
Deno.writeTextFile(
  "./out/exi/afk/setup_team.mcfunction",
  setupTeams.join("\n")
);

setupTeams = [AUTOGENERATED_MESSAGE];

[...data.teams.values()].forEach((team) => {
  let count = 1;
  data.pronouns.single.forEach((single) => {
    setupTeams.push(
      `team join ${team.name}_${single} @s[scores={mpp_pronouns_select=${count}},tag=!mpp_afk,tag=pronouns_${team.name}]`
    );
    count++;
  });
  data.pronouns.pairs.forEach((x) => {
    data.pronouns.pairs.forEach((y) => {
      if (x != y) {
        setupTeams.push(
          `team join ${team.name}_${x}_${y} @s[scores={mpp_pronouns_select=${count}},tag=!mpp_afk,tag=pronouns_${team.name}]`
        );
        count++;
      }
    });
  });
  data.pronouns.triples.forEach((x) => {
    data.pronouns.triples.forEach((y) => {
      data.pronouns.triples.forEach((z) => {
        if (x != y && y != z && x != z) {
          setupTeams.push(
            `team join ${team.name}_${x}_${y}_${z} @s[scores={mpp_pronouns_select=${count}},tag=!mpp_afk,tag=pronouns_${team.name}]`
          );
          count++;
        }
      });
    });
  });
  setupTeams.push(
    `team join ${team.name} @s[scores={mpp_pronouns_select=${count}},tag=!mpp_afk,tag=pronouns_${team.name}]`
  );
});
setupTeams.push(
  "advancement grant @s[scores={mpp_pronouns_select=1..}] only mcpeachpies:pronouns/me_myself_and_i",
  "scoreboard players set @s[scores={mpp_pronouns_select=1..}] mpp_pronouns_select 0"
);
Deno.writeTextFile("./out/exi/check_team.mcfunction", setupTeams.join("\n"));

setupTeams = [
  AUTOGENERATED_MESSAGE,
  "execute as @s[tag=!mpp_afk_mig] run function mcpeachpies_afk_detector:scoreboard_migration",
  "execute as @s[tag=!mpp_afk_advu] run function mcpeachpies_afk_detector:advancement_update",
  "scoreboard players set @s mpp_afk_death 0",
  'tellraw @a ["",{"selector":"@s"},{"text":" is now away from their keyboard","color":"gray"}]',
  "team join mpp_afk @s[team=]",
  "team join afk_Staff @s[team=Staff]",
  "team join afk_StaffPatron @s[team=StaffPatron]",
  "team join afk_Patron @s[team=Patron]",
  "team join afk_Trusted @s[team=Trusted]",
];

[...data.teams.values()].forEach((team) => {
  data.pronouns.single.forEach((single) => {
    setupTeams.push(
      `team join afk_${team.name}_${single} @s[team=${team.name}_${single}]`
    );
  });
  data.pronouns.pairs.forEach((x) => {
    data.pronouns.pairs.forEach((y) => {
      if (x != y) {
        setupTeams.push(
          `team join afk_${team.name}_${x}_${y} @s[team=${team.name}_${x}_${y}]`
        );
      }
    });
  });
  data.pronouns.triples.forEach((x) => {
    data.pronouns.triples.forEach((y) => {
      data.pronouns.triples.forEach((z) => {
        if (x != y && y != z && x != z) {
          setupTeams.push(
            `team join afk_${team.name}_${x}_${y}_${z} @s[team=${team.name}_${x}_${y}_${z}]`
          );
        }
      });
    });
  });
});
setupTeams.push("tag @s add mpp_afk");
Deno.writeTextFile("./out/exi/afk/afk_away.mcfunction", setupTeams.join("\n"));

setupTeams = [
  AUTOGENERATED_MESSAGE,
  "team leave @s[team=mpp_afk]",
  "team join Staff @s[team=afk_Staff]",
  "team join StaffPatron @s[team=afk_StaffPatron]",
  "team join Patron @s[team=afk_Patron]",
  "team join Trusted @s[team=afk_Trusted]",
];

[...data.teams.values()].forEach((team) => {
  data.pronouns.single.forEach((single) => {
    setupTeams.push(
      `team join ${team.name}_${single} @s[team=afk_${team.name}_${single}]`
    );
  });
  data.pronouns.pairs.forEach((x) => {
    data.pronouns.pairs.forEach((y) => {
      if (x != y) {
        setupTeams.push(
          `team join ${team.name}_${x}_${y} @s[team=afk_${team.name}_${x}_${y}]`
        );
      }
    });
  });
  data.pronouns.triples.forEach((x) => {
    data.pronouns.triples.forEach((y) => {
      data.pronouns.triples.forEach((z) => {
        if (x != y && y != z && x != z) {
          setupTeams.push(
            `team join ${team.name}_${x}_${y}_${z} @s[team=afk_${team.name}_${x}_${y}_${z}]`
          );
        }
      });
    });
  });
});
setupTeams.push(
  "tag @s remove mpp_afk",
  "advancement grant @s only mcpeachpies:afk_detector/welcome_back",
  "scoreboard players set @s mpp_afk_count 0",
  'tellraw @a ["",{"selector":"@s"},{"text":" is now back at their keyboard","color":"gray"}]'
);
Deno.writeTextFile("./out/exi/afk/afk_back.mcfunction", setupTeams.join("\n"));

setupTeams = [
  AUTOGENERATED_MESSAGE,
  "team add mpp_afk",
  'team modify mpp_afk prefix ["",{"text":"[AFK] ","color":"gray"}]',
];

data.pronouns.single.forEach((single) => {
  createTeam(`afk_mpp_prn_${single}`, "[AFK]", ` [${single}]`, "gray");
});
data.pronouns.pairs.forEach((x) => {
  data.pronouns.pairs.forEach((y) => {
    if (x != y) {
      createTeam(`afk_mpp_prn_${x}_${y}`, "[AFK]", ` [${x}/${y}]`, "gray");
    }
  });
});
data.pronouns.triples.forEach((x) => {
  data.pronouns.triples.forEach((y) => {
    data.pronouns.triples.forEach((z) => {
      if (x != y && y != z && x != z) {
        createTeam(
          `afk_mpp_prn_${x}_${y}_${z}`,
          "[AFK]",
          ` [${x}/${y}/${z}]`,
          "gray"
        );
      }
    });
  });
});

console.log(`Created ${(setupTeams.length - 2) / 4} teams for AFK Detector`);
Deno.writeTextFile("./out/afk/setup_team.mcfunction", setupTeams.join("\n"));

setupTeams = [AUTOGENERATED_MESSAGE];

data.pronouns.single.forEach((single) => {
  createTeam(`mpp_prn_${single}`, undefined, ` [${single}]`, undefined);
});
data.pronouns.pairs.forEach((x) => {
  data.pronouns.pairs.forEach((y) => {
    if (x != y) {
      createTeam(`mpp_prn_${x}_${y}`, undefined, ` [${x}/${y}]`, undefined);
    }
  });
});
data.pronouns.triples.forEach((x) => {
  data.pronouns.triples.forEach((y) => {
    data.pronouns.triples.forEach((z) => {
      if (x != y && y != z && x != z) {
        createTeam(
          `mpp_prn_${x}_${y}_${z}`,
          undefined,
          ` [${x}/${y}/${z}]`,
          undefined
        );
      }
    });
  });
});

console.log(`Created ${(setupTeams.length - 1) / 2} teams for Pronouns`);
Deno.writeTextFile("./out/setup_team.mcfunction", setupTeams.join("\n"));

setupTeams = [AUTOGENERATED_MESSAGE];

data.pronouns.single.forEach((single) => {
  setupTeams.push(
    `team join mpp_prn_${single} @s[scores={mpp_pronouns_select=${setupTeams.length}},tag=!mpp_afk]`
  );
});
data.pronouns.pairs.forEach((x) => {
  data.pronouns.pairs.forEach((y) => {
    if (x != y) {
      setupTeams.push(
        `team join mpp_prn_${x}_${y} @s[scores={mpp_pronouns_select=${setupTeams.length}},tag=!mpp_afk]`
      );
    }
  });
});
data.pronouns.triples.forEach((x) => {
  data.pronouns.triples.forEach((y) => {
    data.pronouns.triples.forEach((z) => {
      if (x != y && y != z && x != z) {
        setupTeams.push(
          `team join mpp_prn_${x}_${y}_${z} @s[scores={mpp_pronouns_select=${setupTeams.length}},tag=!mpp_afk]`
        );
      }
    });
  });
});
setupTeams.push(
  `team leave @s[scores={mpp_pronouns_select=${setupTeams.length}},tag=!mpp_afk]`,
  "advancement grant @s[scores={mpp_pronouns_select=1..}] only mcpeachpies:pronouns/me_myself_and_i",
  "scoreboard players set @s[scores={mpp_pronouns_select=1..}] mpp_pronouns_select 0"
);
Deno.writeTextFile("./out/check_team.mcfunction", setupTeams.join("\n"));

setupTeams = [
  AUTOGENERATED_MESSAGE,
  "execute as @s[tag=!mpp_afk_mig] run function mcpeachpies_afk_detector:scoreboard_migration",
  "execute as @s[tag=!mpp_afk_advu] run function mcpeachpies_afk_detector:advancement_update",
  "scoreboard players set @s mpp_afk_death 0",
  'tellraw @a ["",{"selector":"@s"},{"text":" is now away from their keyboard","color":"gray"}]',
  "team join mpp_afk @s[team=]",
];
data.pronouns.single.forEach((single) => {
  setupTeams.push(`team join afk_mpp_prn_${single} @s[team=mpp_prn_${single}]`);
});
data.pronouns.pairs.forEach((x) => {
  data.pronouns.pairs.forEach((y) => {
    if (x != y) {
      setupTeams.push(
        `team join afk_mpp_prn_${x}_${y} @s[team=mpp_prn_${x}_${y}]`
      );
    }
  });
});
data.pronouns.triples.forEach((x) => {
  data.pronouns.triples.forEach((y) => {
    data.pronouns.triples.forEach((z) => {
      if (x != y && y != z && x != z) {
        setupTeams.push(
          `team join afk_mpp_prn_${x}_${y}_${z} @s[team=mpp_prn_${x}_${y}_${z}]`
        );
      }
    });
  });
});
setupTeams.push("tag @s add mpp_afk");
Deno.writeTextFile("./out/afk/afk_away.mcfunction", setupTeams.join("\n"));

setupTeams = [AUTOGENERATED_MESSAGE, "team leave @s[team=mpp_afk]"];
data.pronouns.single.forEach((single) => {
  setupTeams.push(`team join mpp_prn_${single} @s[team=afk_mpp_prn_${single}]`);
});
data.pronouns.pairs.forEach((x) => {
  data.pronouns.pairs.forEach((y) => {
    if (x != y) {
      setupTeams.push(
        `team join mpp_prn_${x}_${y} @s[team=afk_mpp_prn_${x}_${y}]`
      );
    }
  });
});
data.pronouns.triples.forEach((x) => {
  data.pronouns.triples.forEach((y) => {
    data.pronouns.triples.forEach((z) => {
      if (x != y && y != z && x != z) {
        setupTeams.push(
          `team join mpp_prn_${x}_${y}_${z} @s[team=afk_mpp_prn_${x}_${y}_${z}]`
        );
      }
    });
  });
});
setupTeams.push(
  "tag @s remove mpp_afk",
  "advancement grant @s only mcpeachpies:afk_detector/welcome_back",
  "scoreboard players set @s mpp_afk_count 0",
  'tellraw @a ["",{"selector":"@s"},{"text":" is now back at their keyboard","color":"gray"}]'
);
Deno.writeTextFile("./out/afk/afk_back.mcfunction", setupTeams.join("\n"));

setupTeams = [AUTOGENERATED_MESSAGE];

[...data.teams.values()].forEach((team) => {
  data.pronouns.single.forEach((single) => {
    setupTeams.push(`team remove ${team.name}_${single}`);
    setupTeams.push(`team remove afk_${team.name}_${single}`);
  });
  data.pronouns.pairs.forEach((x) => {
    data.pronouns.pairs.forEach((y) => {
      if (x != y) {
        setupTeams.push(`team remove ${team.name}_${x}_${y}`);
        setupTeams.push(`team remove afk_${team.name}_${x}_${y}`);
      }
    });
  });
  data.pronouns.triples.forEach((x) => {
    data.pronouns.triples.forEach((y) => {
      data.pronouns.triples.forEach((z) => {
        if (x != y && y != z && x != z) {
          setupTeams.push(`team remove ${team.name}_${x}_${y}_${z}`);
          setupTeams.push(`team remove afk_${team.name}_${x}_${y}_${z}`);
        }
      });
    });
  });
});
setupTeams.push(
  "scoreboard objectives remove pronouns",
  "scoreboard objectives remove mpp_pronouns_select",
  "scoreboard players reset mpp_pronouns_setup mpp_datapacks"
);
Deno.writeTextFile("./out/exi/uninstall.mcfunction", setupTeams.join("\n"));

setupTeams = [AUTOGENERATED_MESSAGE];

data.pronouns.single.forEach((single) => {
  setupTeams.push(`team remove mpp_prn_${single}`);
  setupTeams.push(`team remove afk_mpp_prn_${single}`);
});
data.pronouns.pairs.forEach((x) => {
  data.pronouns.pairs.forEach((y) => {
    if (x != y) {
      setupTeams.push(`team remove mpp_prn_${x}_${y}`);
      setupTeams.push(`team remove afk_mpp_prn_${x}_${y}`);
    }
  });
});
data.pronouns.triples.forEach((x) => {
  data.pronouns.triples.forEach((y) => {
    data.pronouns.triples.forEach((z) => {
      if (x != y && y != z && x != z) {
        setupTeams.push(`team remove mpp_prn_${x}_${y}_${z}`);
        setupTeams.push(`team remove afk_mpp_prn_${x}_${y}_${z}`);
      }
    });
  });
});
setupTeams.push(
  "scoreboard objectives remove pronouns",
  "scoreboard objectives remove mpp_pronouns_select",
  "scoreboard players reset mpp_pronouns_setup mpp_datapacks"
);
Deno.writeTextFile("./out/uninstall.mcfunction", setupTeams.join("\n"));

console.log(`Check ./out for setup files`);
