import data from "../data.json" assert { type: "json" };

const AUTOGENERATED_MESSAGE =
  "# Autogenerated by https://github.com/mcpeachpies/mcpeachpies-datapacks/blob/master/pronouns/.generate_teams";

let setupTeams: string[] = [AUTOGENERATED_MESSAGE];

function createTeam(
  name: string,
  prefix: string | undefined,
  suffix: string,
  color: string | undefined
) {
  setupTeams.push(`team add ${name}`);
  if (prefix)
    setupTeams.push(
      `team modify ${name} prefix ["",{"text":"${prefix} ","color":"${
        color || "reset"
      }"}]`
    );
  setupTeams.push(
    `team modify ${name} suffix ["",{"text":"${suffix}","color":"gray"}]`
  );
  if (color) setupTeams.push(`team modify ${name} color ${color}`);
}

[...data.teams.values()].forEach((team) => {
  data.pronouns.single.forEach((single) => {
    createTeam(
      `${team.name}_${single}`,
      team.prefix,
      ` [${single}]`,
      team.color
    );
    createTeam(
      `afk_${team.name}_${single}`,
      team.prefix,
      ` [${single}]`,
      "gray"
    );
  });
  data.pronouns.pairs.forEach((x) => {
    data.pronouns.pairs.forEach((y) => {
      if (x != y) {
        createTeam(
          `${team.name}_${x}_${y}`,
          team.prefix,
          ` [${x}/${y}]`,
          team.color
        );
        createTeam(
          `afk_${team.name}_${x}_${y}`,
          team.prefix,
          ` [${x}/${y}]`,
          "gray"
        );
      }
    });
  });
  data.pronouns.triples.forEach((x) => {
    data.pronouns.triples.forEach((y) => {
      data.pronouns.triples.forEach((z) => {
        if (x != y && y != z && x != z) {
          createTeam(
            `${team.name}_${x}_${y}_${z}`,
            team.prefix,
            ` [${x}/${y}/${z}]`,
            team.color
          );
          createTeam(
            `afk_${team.name}_${x}_${y}_${z}`,
            team.prefix,
            ` [${x}/${y}/${z}]`,
            "gray"
          );
        }
      });
    });
  });
});

console.log(
  `Created ${
    (setupTeams.length - 1) / 4
  } teams for Pronouns, Existence SMP Handler, & AFK Detector`
);
Deno.writeTextFile("./out/exi/setup_team.mcfunction", setupTeams.join("\n"));

setupTeams = [
  AUTOGENERATED_MESSAGE,
  "team add mpp_afk",
  'team modify mpp_afk prefix ["",{"text":"[AFK] ","color":"gray"}]',
];

data.pronouns.single.forEach((single) => {
  createTeam(`afk_mpp_prn_${single}`, "[AFK]", ` [${single}]`, "gray");
});
data.pronouns.pairs.forEach((x) => {
  data.pronouns.pairs.forEach((y) => {
    if (x != y) {
      createTeam(`afk_mpp_prn_${x}_${y}`, "[AFK]", ` [${x}/${y}]`, "gray");
    }
  });
});
data.pronouns.triples.forEach((x) => {
  data.pronouns.triples.forEach((y) => {
    data.pronouns.triples.forEach((z) => {
      if (x != y && y != z && x != z) {
        createTeam(
          `afk_mpp_prn_${x}_${y}_${z}`,
          "[AFK]",
          ` [${x}/${y}/${z}]`,
          "gray"
        );
      }
    });
  });
});

console.log(`Created ${(setupTeams.length - 1) / 4} teams for AFK Detector`);
Deno.writeTextFile("./out/afk/setup_team.mcfunction", setupTeams.join("\n"));

setupTeams = [AUTOGENERATED_MESSAGE];

data.pronouns.single.forEach((single) => {
  createTeam(`mpp_prn_${single}`, undefined, ` [${single}]`, undefined);
});
data.pronouns.pairs.forEach((x) => {
  data.pronouns.pairs.forEach((y) => {
    if (x != y) {
      createTeam(`mpp_prn_${x}_${y}`, undefined, ` [${x}/${y}]`, undefined);
    }
  });
});
data.pronouns.triples.forEach((x) => {
  data.pronouns.triples.forEach((y) => {
    data.pronouns.triples.forEach((z) => {
      if (x != y && y != z && x != z) {
        createTeam(
          `mpp_prn_${x}_${y}_${z}`,
          undefined,
          ` [${x}/${y}/${z}]`,
          undefined
        );
      }
    });
  });
});

console.log(`Created ${(setupTeams.length - 1) / 2} teams for Pronouns`);
Deno.writeTextFile("./out/setup_team.mcfunction", setupTeams.join("\n"));

setupTeams = [AUTOGENERATED_MESSAGE];

data.pronouns.single.forEach((single) => {
  setupTeams.push(
    `team join mpp_prn_${single} @s[scores={mpp_pronouns_select=${setupTeams.length}},tag=!mpp_afk]`
  );
});
data.pronouns.pairs.forEach((x) => {
  data.pronouns.pairs.forEach((y) => {
    if (x != y) {
      setupTeams.push(
        `team join mpp_prn_${x}_${y} @s[scores={mpp_pronouns_select=${setupTeams.length}},tag=!mpp_afk]`
      );
    }
  });
});
data.pronouns.triples.forEach((x) => {
  data.pronouns.triples.forEach((y) => {
    data.pronouns.triples.forEach((z) => {
      if (x != y && y != z && x != z) {
        setupTeams.push(
          `team join mpp_prn_${x}_${y}_${z} @s[scores={mpp_pronouns_select=${setupTeams.length}},tag=!mpp_afk]`
        );
      }
    });
  });
});
setupTeams.push(
  `team leave @s[scores={mpp_pronouns_select=${setupTeams.length}},tag=!mpp_afk]`,
  "scoreboard players set @a[scores={mpp_pronouns_select=1..}] mpp_pronouns_select 0"
);
Deno.writeTextFile("./out/check_team.mcfunction", setupTeams.join("\n"));

setupTeams = [
  AUTOGENERATED_MESSAGE,
  "execute as @s[tag=!mpp_afk_mig] run function mcpeachpies_afk_detector:scoreboard_migration",
  "execute as @s[tag=!mpp_afk_advu] run function mcpeachpies_afk_detector:advancement_update",
  "scoreboard players set @s mpp_afk_death 0",
  'tellraw @a ["",{"selector":"@s"},{"text":" is now away from their keyboard","color":"gray"}]',
  "team join mpp_afk @s[team=]",
];
data.pronouns.single.forEach((single) => {
  setupTeams.push(`team join afk_mpp_prn_${single} @s[team=mpp_prn_${single}]`);
});
data.pronouns.pairs.forEach((x) => {
  data.pronouns.pairs.forEach((y) => {
    if (x != y) {
      setupTeams.push(
        `team join afk_mpp_prn_${x}_${y} @s[team=mpp_prn_${x}_${y}]`
      );
    }
  });
});
data.pronouns.triples.forEach((x) => {
  data.pronouns.triples.forEach((y) => {
    data.pronouns.triples.forEach((z) => {
      if (x != y && y != z && x != z) {
        setupTeams.push(
          `team join afk_mpp_prn_${x}_${y}_${z} @s[team=mpp_prn_${x}_${y}_${z}]`
        );
      }
    });
  });
});
setupTeams.push("tag @s add mpp_afk");
Deno.writeTextFile("./out/afk/afk_away.mcfunction", setupTeams.join("\n"));

setupTeams = [AUTOGENERATED_MESSAGE, "team leave @s[team=mpp_afk]"];
data.pronouns.single.forEach((single) => {
  setupTeams.push(`team join mpp_prn_${single} @s[team=afk_mpp_prn_${single}]`);
});
data.pronouns.pairs.forEach((x) => {
  data.pronouns.pairs.forEach((y) => {
    if (x != y) {
      setupTeams.push(
        `team join mpp_prn_${x}_${y} @s[team=afk_mpp_prn_${x}_${y}]`
      );
    }
  });
});
data.pronouns.triples.forEach((x) => {
  data.pronouns.triples.forEach((y) => {
    data.pronouns.triples.forEach((z) => {
      if (x != y && y != z && x != z) {
        setupTeams.push(
          `team join mpp_prn_${x}_${y}_${z} @s[team=afk_mpp_prn_${x}_${y}_${z}]`
        );
      }
    });
  });
});
setupTeams.push(
  "tag @s remove mpp_afk",
  "advancement grant @s only mcpeachpies:afk_detector/welcome_back",
  "scoreboard players set @s mpp_afk_count 0",
  'tellraw @a ["",{"selector":"@s"},{"text":" is now back at their keyboard","color":"gray"}]'
);
Deno.writeTextFile("./out/afk/afk_back.mcfunction", setupTeams.join("\n"));

console.log(`Check ./out for setup files`);
